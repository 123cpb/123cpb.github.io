<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadowboxing Combo Generator</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: white;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            flex-grow: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 2px 2px 4px rgba(0,0,0,0.3), 0 0 10px rgba(255,255,255,0.2); }
            to { text-shadow: 2px 2px 4px rgba(0,0,0,0.3), 0 0 20px rgba(255,255,255,0.4); }
        }

        .controls {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        label {
            font-weight: bold;
            min-width: 120px;
        }

        input, select, button {
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input, select {
            background: rgba(255,255,255,0.9);
            color: #333;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }

        input:focus, select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255,255,255,0.3);
            transform: scale(1.02);
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            filter: brightness(1.1);
        }

        button:active {
            transform: translateY(-1px);
        }

        button:disabled {
            background: linear-gradient(45deg, #666, #555);
            cursor: not-allowed;
            transform: none;
            filter: none;
        }

        .combo-display {
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            border: 2px solid rgba(255,255,255,0.3);
            margin-bottom: 30px;
            box-shadow: inset 0 4px 20px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .combo-display::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: rotate(45deg);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            50% { transform: translateX(100%) translateY(100%) rotate(45deg); }
            100% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
        }

        .combo-text {
            font-size: 2em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            position: relative;
            z-index: 2;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .timer {
            font-size: 1.5em;
            color: #ffeb3b;
            font-weight: bold;
            position: relative;
            z-index: 2;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .combo-management {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .combo-list {
            max-height: 250px;
            overflow-y: auto;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .combo-list::-webkit-scrollbar {
            width: 8px;
        }

        .combo-list::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        .combo-list::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
        }

        .combo-item {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .combo-item:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }

        .delete-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .delete-btn:hover {
            background: linear-gradient(45deg, #c0392b, #a93226);
            transform: scale(1.1);
        }

        .status {
            text-align: center;
            margin-top: 15px;
            font-weight: bold;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            min-height: 20px;
        }

        .training-mode {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { border-color: rgba(255,255,255,0.3); }
            50% { border-color: rgba(255,235,59,0.8); }
        }

        @media (max-width: 600px) {
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }

            label {
                min-width: auto;
            }

            .combo-text {
                font-size: 1.5em;
            }

            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü•ä Shadowboxing Combo Generator</h1>
            <p>Train like a champion with random boxing combinations</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="intervalMode">Timing Mode:</label>
                <select id="intervalMode" onchange="toggleIntervalMode()">
                    <option value="fixed">Fixed Interval</option>
                    <option value="random">Random Interval (2-10s)</option>
                    <option value="custom-random">Custom Random Range</option>
                </select>
            </div>
            <div class="control-group" id="fixedIntervalGroup">
                <label for="interval">Display Time (seconds):</label>
                <input type="number" id="interval" value="5" min="1" max="60">
            </div>
            <div class="control-group" id="randomIntervalGroup" style="display: none;">
                <label for="minInterval">Min Time (seconds):</label>
                <input type="number" id="minInterval" value="2" min="1" max="30">
                <label for="maxInterval">Max Time (seconds):</label>
                <input type="number" id="maxInterval" value="10" min="2" max="60">
            </div>
            <div class="control-group">
                <button id="startBtn" onclick="startTraining()">üöÄ Start Training</button>
                <button id="stopBtn" onclick="stopTraining()" disabled>‚èπÔ∏è Stop Training</button>
                <button onclick="showNextCombo()">‚è≠Ô∏è Next Combo</button>
            </div>
        </div>

        <div class="combo-display" id="comboDisplay">
            <div class="combo-text" id="comboText">Ready to train! Add some combos below and hit Start Training.</div>
            <div class="timer" id="timer"></div>
        </div>

        <div class="combo-management">
            <h3>ü•ä Manage Your Combos</h3>
            <div class="control-group">
                <input type="text" id="newCombo" placeholder="Enter a new combo (e.g., Jab-Cross-Hook-Uppercut)" style="flex-grow: 1;">
                <button onclick="addCombo()">‚ûï Add Combo</button>
            </div>
            <div class="control-group">
                <button onclick="resetCombos()">üîÑ Reset to Defaults</button>
                <button onclick="exportCombos()">üì§ Export Combos</button>
                <button onclick="showImportDialog()">üì• Import Combos</button>
            </div>
            <div class="combo-list" id="comboList"></div>
            <div class="status" id="status"></div>
        </div>
    </div>

    <script>
        class ComboGenerator {
            constructor() {
                this.defaultCombos = [
                    "Jab-Cross",
                    "Jab-Cross-Hook",
                    "Jab-Cross-Hook-Cross",
                    "Hook-Cross-Hook",
                    "Uppercut-Cross-Hook",
                    "Jab-Uppercut-Cross",
                    "Double Jab-Cross",
                    "Jab-Cross-Uppercut-Hook",
                    "Slip-Cross-Hook",
                    "Duck-Uppercut-Cross",
                    "Parry-Jab-Cross",
                    "Weave-Hook-Cross"
                ];
                this.combos = this.loadCombos();
            }

            loadCombos() {
                try {
                    const saved = localStorage.getItem('shadowboxing-combos');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        // Ensure we have at least the default combos if saved data is empty
                        return parsed.length > 0 ? parsed : [...this.defaultCombos];
                    }
                } catch (e) {
                    console.warn('Could not load saved combos:', e);
                }
                return [...this.defaultCombos];
            }

            saveCombos() {
                try {
                    localStorage.setItem('shadowboxing-combos', JSON.stringify(this.combos));
                    return true;
                } catch (e) {
                    console.warn('Could not save combos:', e);
                    return false;
                }
            }

            addCombo(combo) {
                if (combo && combo.trim() && !this.combos.includes(combo.trim())) {
                    this.combos.push(combo.trim());
                    this.saveCombos();
                    return true;
                }
                return false;
            }

            removeCombo(combo) {
                const index = this.combos.indexOf(combo);
                if (index > -1 && this.combos.length > 1) {
                    this.combos.splice(index, 1);
                    this.saveCombos();
                    return true;
                }
                return false;
            }

            getRandomCombo() {
                if (this.combos.length === 0) {
                    return "No combos available";
                }
                return this.combos[Math.floor(Math.random() * this.combos.length)];
            }

            getAllCombos() {
                return [...this.combos];
            }

            getComboCount() {
                return this.combos.length;
            }

            resetToDefaults() {
                this.combos = [...this.defaultCombos];
                this.saveCombos();
                return true;
            }

            exportCombos() {
                return JSON.stringify(this.combos, null, 2);
            }

            importCombos(jsonString) {
                try {
                    const imported = JSON.parse(jsonString);
                    if (Array.isArray(imported) && imported.length > 0) {
                        this.combos = imported.filter(combo => typeof combo === 'string' && combo.trim());
                        if (this.combos.length === 0) {
                            this.combos = [...this.defaultCombos];
                        }
                        this.saveCombos();
                        return true;
                    }
                } catch (e) {
                    console.warn('Could not import combos:', e);
                }
                return false;
            }
        }

        const generator = new ComboGenerator();
        let isTraining = false;
        let trainingInterval;
        let countdownInterval;
        let timeLeft = 0;
        let currentIntervalDuration = 0;

        function toggleIntervalMode() {
            const mode = document.getElementById('intervalMode').value;
            const fixedGroup = document.getElementById('fixedIntervalGroup');
            const randomGroup = document.getElementById('randomIntervalGroup');
            
            if (mode === 'fixed') {
                fixedGroup.style.display = 'flex';
                randomGroup.style.display = 'none';
            } else if (mode === 'random') {
                fixedGroup.style.display = 'none';
                randomGroup.style.display = 'none';
            } else if (mode === 'custom-random') {
                fixedGroup.style.display = 'none';
                randomGroup.style.display = 'flex';
            }
        }

        function getNextInterval() {
            const mode = document.getElementById('intervalMode').value;
            
            if (mode === 'fixed') {
                return parseInt(document.getElementById('interval').value) || 5;
            } else if (mode === 'random') {
                return Math.floor(Math.random() * 9) + 2; // 2-10 seconds
            } else if (mode === 'custom-random') {
                const min = parseInt(document.getElementById('minInterval').value) || 2;
                const max = parseInt(document.getElementById('maxInterval').value) || 10;
                const actualMin = Math.min(min, max);
                const actualMax = Math.max(min, max);
                return Math.floor(Math.random() * (actualMax - actualMin + 1)) + actualMin;
            }
            return 5;
        }

        function addCombo() {
            const newComboInput = document.getElementById('newCombo');
            const combo = newComboInput.value.trim();
            
            if (combo) {
                const result = generator.addCombo(combo);
                
                if (result) {
                    newComboInput.value = '';
                    updateComboList();
                    updateStatus();
                    showStatus(`‚úÖ Added: "${combo}"`, 'success');
                } else {
                    showStatus('‚ùå Combo already exists or is empty', 'error');
                }
            } else {
                showStatus('‚ùå Please enter a combo', 'error');
            }
        }

        function removeCombo(combo) {
            const result = generator.removeCombo(combo);
            
            if (result) {
                updateComboList();
                updateStatus();
                showStatus(`üóëÔ∏è Removed: "${combo}"`, 'success');
            } else {
                showStatus('‚ùå Cannot remove - need at least one combo', 'error');
            }
        }

        function updateComboList() {
            const combos = generator.getAllCombos();
            const comboList = document.getElementById('comboList');
            
            comboList.innerHTML = '';
            
            combos.forEach(combo => {
                const div = document.createElement('div');
                div.className = 'combo-item';
                div.innerHTML = `
                    <span>ü•ä ${combo}</span>
                    <button class="delete-btn" onclick="removeCombo('${combo.replace(/'/g, "\\'")}')">üóëÔ∏è Delete</button>
                `;
                comboList.appendChild(div);
            });
        }

        function updateStatus() {
            const count = generator.getComboCount();
            const isCustomized = JSON.stringify(generator.getAllCombos()) !== JSON.stringify(generator.defaultCombos);
            const statusText = `üìä Total combos: ${count}${isCustomized ? ' (customized)' : ' (defaults)'}`;
            document.getElementById('status').textContent = statusText;
        }

        function resetCombos() {
            if (confirm('‚ö†Ô∏è This will reset all combos to defaults and remove your custom additions. Continue?')) {
                generator.resetToDefaults();
                updateComboList();
                updateStatus();
                showStatus('üîÑ Reset to default combos', 'success');
            }
        }

        function exportCombos() {
            const exported = generator.exportCombos();
            navigator.clipboard.writeText(exported).then(() => {
                showStatus('üì§ Combos copied to clipboard!', 'success');
            }).catch(() => {
                // Fallback for browsers that don't support clipboard API
                const textarea = document.createElement('textarea');
                textarea.value = exported;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showStatus('üì§ Combos copied to clipboard!', 'success');
            });
        }

        function showImportDialog() {
            const jsonInput = prompt('üì• Paste your exported combos JSON here:');
            if (jsonInput) {
                const success = generator.importCombos(jsonInput);
                if (success) {
                    updateComboList();
                    updateStatus();
                    showStatus('üì• Combos imported successfully!', 'success');
                } else {
                    showStatus('‚ùå Invalid format. Please check your JSON.', 'error');
                }
            }
        }

        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            
            // Clear any existing timeout
            if (window.statusTimeout) {
                clearTimeout(window.statusTimeout);
            }
            
            // Reset to default status after 3 seconds
            window.statusTimeout = setTimeout(() => {
                updateStatus();
            }, 3000);
        }

        function showNextCombo() {
            const combo = generator.getRandomCombo();
            const comboTextEl = document.getElementById('comboText');
            
            // Add fade out effect
            comboTextEl.style.opacity = '0';
            comboTextEl.style.transform = 'scale(0.8)';
            
            setTimeout(() => {
                comboTextEl.textContent = combo;
                comboTextEl.style.opacity = '1';
                comboTextEl.style.transform = 'scale(1)';
            }, 200);
            
            if (isTraining) {
                startCountdown();
            } else {
                document.getElementById('timer').textContent = '';
            }
        }

        function startCountdown() {
            currentIntervalDuration = getNextInterval();
            timeLeft = currentIntervalDuration;
            
            clearInterval(countdownInterval);
            
            const mode = document.getElementById('intervalMode').value;
            const modeText = mode === 'fixed' ? '' : ` (${mode} mode)`;
            
            const updateTimer = () => {
                if (timeLeft > 0) {
                    document.getElementById('timer').textContent = `‚è±Ô∏è Next combo in: ${timeLeft}s${modeText}`;
                    timeLeft--;
                } else {
                    document.getElementById('timer').textContent = 'üîÑ Loading next combo...';
                }
            };
            
            updateTimer();
            countdownInterval = setInterval(updateTimer, 1000);
        }

        function startTraining() {
            const interval = parseInt(document.getElementById('interval').value) || 5;
            const comboCount = generator.getComboCount();
            
            if (comboCount === 0) {
                showStatus('‚ùå Please add at least one combo before starting training', 'error');
                return;
            }
            
            isTraining = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('comboDisplay').classList.add('training-mode');
            
            showStatus('üöÄ Training started! Keep moving!', 'success');
            showNextCombo();
            
            trainingInterval = setInterval(() => {
                showNextCombo();
            }, interval * 1000);
        }

        function stopTraining() {
            isTraining = false;
            clearInterval(trainingInterval);
            clearInterval(countdownInterval);
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('comboDisplay').classList.remove('training-mode');
            document.getElementById('timer').textContent = '';
            document.getElementById('comboText').textContent = '‚èπÔ∏è Training stopped. Ready to start again!';
            
            showStatus('‚èπÔ∏è Training stopped. Great work!', 'info');
        }

        // Handle Enter key in the combo input
        document.getElementById('newCombo').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addCombo();
            }
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            updateComboList();
            updateStatus();
            
            // Show welcome message for returning users
            const isReturningUser = localStorage.getItem('shadowboxing-combos');
            if (isReturningUser) {
                setTimeout(() => {
                    showStatus('üëã Welcome back! Your combos have been restored.', 'success');
                }, 500);
            }
        });

        // Prevent accidental page refresh during training
        window.addEventListener('beforeunload', function(e) {
            if (isTraining) {
                e.preventDefault();
                e.returnValue = 'Training is in progress. Are you sure you want to leave?';
                return e.returnValue;
            }
        });
    </script>
</body>
</html>